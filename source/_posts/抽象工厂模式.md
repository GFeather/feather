---
title: 抽象工厂模式
date: 2018-08-27 13:49:11
tags: [设计模式]
categories: 设计模式
respository: git@github.com:Gfeather/feather.git
branch: master
---
*learning ,  perception design* 

## 抽象工厂模式

#### 定义
提供一个创建一组相关或者依赖的对象的接口，无需指定具体类，把创建对象完全封装

#### 实现

{% asset_img 抽象工厂模式.png %}

```
//产品族A
public abstract class AbstractProductA{
	public void use();
} 
public class ProductA1 extends AbstractProductA{
	public void use(){}
}
public class ProductA2 extends AbstractProductA{
	public void use(){}
}
//产品族B
public abstract class AbstractProductB{
	public void use();
} 
public class ProductB1 extends AbstractProductB{
	public void use(){}
}
public class ProductB2 extends AbstractProductB{
	public void use(){}
}
```
```
//抽象工厂，每个产品等级都有一个对应类，每个产品族都有一个对应的方法
public abstract class AbstractCreator{
	public AbstractProductA createA();
	public AbstractProductB createB();
}
public class Creator1 extends AbstractCreator{
	public AbstractProductA createA(){return new ProductA1();}
	public AbstractProductB createB(){return new ProductB1();}
}
public class Creator2 extends AbstractCreator{
	public AbstractProductA createA(){return new ProductA2();}
	public AbstractProductB createB(){return new ProductB2();}
}
//eg：产品族分别为文本处理软件、视频处理软件等软件种类，那么产品等级就为Unix平台和Windows平台等操作系统平台，
每个产品族具有所需支持平台的所有版本，每个抽象工厂类都可以创建出对应平台的一套软件
```
```
//场景
public Sea{
	public static void main(String[] args){
		AbstractCreator creator1 = new Creator1();
		ProductA productA = creator1.createA();
		ProductB productB = creator1.createB();
		//创建了等级1的一组对象，不需要了解内部细节
	}
}
```

#### 应用
>  优点：抽象工厂模式具有完全的封装，可以将创建对象的细节、以及其他约束全部封装在工厂中，用户只需要知道工厂就可以创建约定好的对象
>  缺点：拓展性差，抽象工厂模式的工厂都依赖抽象工厂类，即接口，当需要拓展时，就需要修改抽象工厂类。增加产品等级时，只需要增加一个相应等级的生产类。当增加产品族时，所有的工厂类都要修改增加相应的生产方法。

#### End
简单讲，当一个产品族具有相同约束，即使用环境是同一类别的不同种类，就可以使用抽象工厂模式
使用时产品族应该是确定的，即具有明确的业务、应用、功能种类。
eg：一个Android平台的app想要拓展到ios、win平台，因为有明确的业务、功能即产品族，所以直接增加一个工厂类就能完成拓展。


*参考《设计模式之禅》*