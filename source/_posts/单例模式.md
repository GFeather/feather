---
title: 单例模式
date: 2018-08-26 19:26:24
tags: [设计模式]
categories: 设计模式
respository: git@github.com:Gfeather/feather.git
branch: master
---
*learning ,  perception design* 

## 单例模式

#### 什么是单例
单例的核心理念就是确保一个类只有一个实例，这也是实现单例的base。

#### 作用
也就是遇到的问题，单例这个特性解决的问题有两方面，一是需要单例的场景、二是减少内存损耗提高性能的需求。第一条问题是某些操作必须或者尽量由一个对象去完成，比如多入口的IO等。。。第二条可能是老板和Engineer都喜欢看到的，如果一个类型的实例频繁被创建、调用，那么使这些调用都操作一个对象就成了一个很自然的需求。

#### 实现
由具体的实现方法、获取对象细节则细分出几个几个种类，大体在功能上分出饿汉式、懒汉式。具体区别则是实例产生时机的早和晚。 

- 饿汉式
> 即在使用之前就已经将对象准备好，代码实现则通常为使用静态成员

	```
	//静态变量
	class Sea{
	    private static final Sea sea = new Sea();
	    public static getInstence(){
			return sea;
		}
	}
	```
	```
	//静态代码块
	class Sea{
		private static final Sea sea;
		static{
			sea = new Sea();
		}
		public static Sea getInstence(){
			return sea;
		}
	}
	```
	> 这两种方法效果相同，都是在类加载时创建对象
	> 优：不存在线程同步问题
	> 缺：如果这个类还有别的功能使用时可能不会使用这个实例，就需要懒加载
- 懒汉式
	> 即在需要使用这个对象的时候产生实例，一般形式为调用`get()`方法时产生对象
	
	```
	//在使用懒加载时需要考虑一定的同步问题
	//不可用样例,多线程环境下可能出现多个线程同时通过`if null`判断，从而产生多个对象
	class Sea{
		private static Sea sea;
		public static Sea getInstence(){
			if (sea == null)
				sea = new Sea();
			return sea;
		}
	}
	```
	```
	//可以直接将该方法定义为同步方法，但效率较低，故不列出
	//在方法内部使用同步，必须用双层判断，一层依然存在绕过的情况
	class Sea{
		private static Sea sea;
		public static Sea getInstence(){
			if (sea == null){
				synchronized (Sea.class){
					if (sea == null)
						sea = new Sea();
				}
			}
			return sea;
		}
	}
	```
	>解决了懒加载问题，效率据说较高
	
	```
	//使用静态内部类实现
	class Sea{
		private static class Ssea{
			private static final Sea sea = new Sea();
		}
		public static Sea getInstence(){
			return Ssea.sea;
		}
	}
	```
	> 同样实现懒加载，因为类只有在主动使用时才会被加载，因为是静态并且用`final`保证单例，效率应该较高
	
	```
	//枚举实现
	enum Sea{
		sea;
		public void doSomething(){}
	}
	```
	> 由虚拟机创建保证单例，以为枚举中的对象为`final`对象，在使用时才会生成对象，所以同时也实现了懒加载

#### End
在我看来，一般而言，使用静态成员的方法适用于永驻内存的监听类、持续处理类的场景(否则可能存在长时间闲置，Jvm垃圾回收的问题)，其他几种通过确保创建对象只发生一次的懒汉式能够工作在突发场景之中

*参考《设计模式之禅》*

*ps:今天吃了据说是北京最好吃的炸酱面的方砖厂胡同69号炸酱面，味道不错，放屁都是那个味儿。。。中戏坐落的小巷子，巷里巷外，一个热闹喧嚣、一个安静出尘，就好像戏里戏外*

	
	

	

	
	
	
