---
title: 工厂方法模式
date: 2018-08-27 09:54:02
tags: [设计模式]
categories: 设计模式
respository: git@github.com:Gfeather/feather.git
branch: master
---
*learning ,  perception design* 

## 工厂方法模式

#### 定义
定义一个用于创建对象的抽象接口，让其子类决定实例化哪个类。

#### 实现

```
//产品类，定义了一个产品线以及子类
public abstract class Product{
	public void use();
} 
public class Product1 extends Product{
	//product的功能
	public void use(){System.out.println("use product1");}
} 
public class Product2 extends Product{
	public void use(){System.out.println("use product2");}
}
```
```
//工厂类
public abstract class Factory{
	//创建对象的方法，参数可以自由选择
	public abstract <T extends Product> T createProduct(Class<T> c);
}
public class productFactory extends Factory{
	public  <T extends Product> T createProduct(Class<T> c){
		Product product = null;
		try{
			//对象的创建和初始化
			product = (Product)Class.forName(c.getName()).newInstence();
		} catch (Exception e){
			//异常处理
		}
		return (T)product;
	}
}
```
```
//场景类
public class sea{
	public static void main(String[] args){
		Factory factory = new productFactory();
		Product product = factory.createProduct(Product1.class);
		/*
		use
		*/
	}
}
```
> 使用了工厂方法之后对象的创建细节就被屏蔽了，就意味着被屏蔽的部分可以在底层修改。而不影响高层使用。
> 如果将工厂方法模式的工厂抽象类去除，将创建对象的方法变为静态，那就变成了简单工厂模式，简单工厂模式不易拓展，但是使用更简单。

#### 作用
工厂方法模式将创建对象的功能集中为一个接口，在扩展时，如果是扩展产品类的种类则只需要增加一个产品类的子类，工厂类不用改变，如果是扩展产品类，则增加一个工厂但是会增加复杂度。在修改时，对象的创建方式、初始化方式都只需要修改工厂的创建方法。工厂方法模式使频繁需要创建、使用的对象的创建和初始化代码可以重用。

#### 扩展
因为工厂方法模式用于创建对象，那么用于创建对象的单例模式就能够用于工厂方法模式，来创建单一对象，只需将创建对象的方法改为单例模式的模板实现，在此不列出。
*待拓展。。。*

#### End
工厂方法模式适用于需要横向扩展产品的场景，因为它具有很强的拓展性，面向产品接口，能够将多个产品抽象封装起来，即拿即用。

*参考《设计模式之禅》*
	