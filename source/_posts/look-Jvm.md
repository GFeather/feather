---
title: look Jvm
date: 2018-11-24 09:09:14
tags: [Jvm]
categories: Java
respository: git@github.com:Gfeather/feather.git
branch: master
---

*learning ,  perception design* 

## look Jvm

##### java体系结构
    java语言
    java class 文件格式
    java应用编程接口
    java虚拟机
##### 1.x
###### 1.3.1，java虚拟机体系结构

主要包含类装载器和执行引擎
类装载器来加载程序的class文件和java api class文件为字节码，由执行引擎运行，调用本地方法调用
java程序通过java虚拟机调用本地方法来访问底层操作系统资源

###### 1.3.2，类装载器的体系结构

启动类装载器，用户定义类装载器
启动类装载器是java虚拟机实现的一部分，用户定义类装载器可以在运行时扩展java应用程序
每个类装载器都有自己的命名空间，即java应用在不同源加载的程序分隔在不同的内存空间互相不能访问

###### 1.3.3，java class文件

可以运行在任何支持java虚拟机的硬件平台和操作系统上

###### 1.3.4 java api

java虚拟机在特定平台上实现java api，java api调用本地方法，java程序则实现无平台性


##### 2.x 平台无关性

取决于是否调用平台相关的本地方法
实现平台无关步骤：
1. 选择程序要运行的主机和设备的集合（目标宿主机）
2. 在目标宿主机算则自认为足够好的java平台版本，在该版本平台上编写、运行程序
3. 对于每个目标宿主机，选择一些程序将要运行的java平台实现（目标运行时环境）
4. 编写程序，使它只通过java api的标准运行库来访问计算机（不要调用本地方法，或者开发商专有的那些调用本地方法的库
5. 编写程序，使它不依赖垃圾收集器及时中介的正确性，也不依赖线程的优先级
6. 努力设计一个用户界面，使它在你所有的目标宿主机上都能正常工作
7. 在所有目标运行时环境和所有的目标宿主机上都能工作

##### 3.x 安全性

沙箱实现
类装载器结构，class文件检验器，内置于java虚拟机（及语言）的安全特性，安全管理器及java api

类加载器：将代码限制在某类中，限制允许的操作

类装载器的加载为链式双亲委派模式：除启动类装载器的每一个类装载器，都有一个“双亲“类装载器，默认将这个任务委派给他的双亲来装在这个类型，直到到达启动类装载器，如果双亲类装载器有能力装载则返回这个类型，否则，类装载器自身来装载

类装载器会验证类型是否可以信任，这样实现了外来非法类无法被装载
因为外来类与核心被信任类不在同一个运行时包所以外来类无法对其他安全类造成危害

运行时包：由同一个类加载器装载的、属于同一个包的、多个类型的集合。

class文件检验器：四次扫描：
1. 第一次，类装载时，检查class文件的内部结构，以保证可以安全编译
2. 第二、三次，连接过程中，确认类型数据遵从java编程语言的语义，包括检验它所包含的的所有字节码的完整性
3. 第四次，在动态连接过程中解析符号引用时，确认被引用的类、字段及方法确实存在，大多数虚拟机有延迟加载策略，即便会预加载以加快装载速度，还是会表现为延迟加载，即如果没有找到被引用类则使用时才会抛出异常
动态连接：将一个符号引用解析为直接引用的过程，

解析：
1）查找被引用的类（有必要则装载）
2）将符号引用替换为直接引用
符号引用是一个字符串，包含类名，方法（字段）名及方法（字段）描述符来唯一地识别一个类、字段或方法

###### 栈：
每个线程都会被授予自己的java栈，每个方法调用有一个自己帧栈，java栈由不同帧栈组成

帧栈是一个内存片段，存储着局部变量和计算的中间结果，其中，存储方法的中间结果的被称为该方法的操作数栈。操作码和它的操作数则可以为操作数栈中的数据或方法帧栈中的局部变量中的数据。

jar文件会做签名来确保可信赖
jar是为了一次传输多个文件的java打包归档文件

##### 4.x 网络移动性
java的class文件设计紧凑，他们的字节码的每条只能只占一个字节，操作码和操作数都是按照字节对齐的，有些特例会在操作码和操作数之间会填上一到三个字节，使操作数都按字边界对齐

JINI技术：
JINI技术通过对象序列化和远程方法调用（RMI），java api能够将本地对象模型拓展为分布式对象模型，打破java虚拟机之间的界限

JINI技术运行时基础架构为一种网络级协议——“探索“，以及对象级协议——”加入”和“查找”

探索过程：当服务提供者插入，连上网络之后，会发送一个UDP网络组播包，包含IP和端口来让查找服务发现

查找服务监听公共端口，接收到包之后判断是否连接，然后建立TCP连接，通过RMI发送一个服务注册器的对象，用于进行进一步操作比如join（加入）和lookup（查找）

JOIN过程：服务注册器对象是探索的结果，服务提供者收到服务注册对象后，调用其中的register()来注册并传递一个服务条目，服务条目包含来描述这个服务的对象，register()把服务条目的拷贝返回给查找服务

服务条目中包含一个服务对象，客户机可以通过它来和服务交互。比如查找对象就是一种JINI服务，他的服务对象就是服务注册对象

随想：JINI服务的核心思想就是通过RMI给对方一个对象，对方通过这个对象来跟自己交互

查找过程：当客户机插入之后，经历探索过程，调用服务注册对象的lookup()方法，传递一个服务模板的参数，这是一个表示搜索条件的对象。它可以包含一个指向class对象数组的引用，这些class对象表明客户机所需要的服务对象的java类型，也可以包含一个服务编号ID来唯一标识一个服务。服务模板的任何字段都可以包含通配符，lookup()方法把这个服务模板返回查找服务进行查询，返回满足条件的服务对象。

##### 5.x	java虚拟机
![](https://i.imgur.com/FWPfeoi.png)
![](https://i.imgur.com/IfnU2vd.png)
虚拟机负责运行一个java程序，运行一个java程序就得到一个java虚拟机实例

###### 方法区：

- 类型信息
	- 类的全限定名
	- 直接超类的全限定名
	- 是类还是接口
	- 访问修饰符
	- 所有直接接口类的全限定名的有序列表
- 常量池（除类常量外）：各种直接常量（Ingeter，String，float point）以- 及其他类型，字段和方法的符号引用，池里的数据像数组一样通过索引访问
- 字段信息
	- 字段名
	- 类型
	- 修饰符
- 方法信息
	- 方法名
	- 方法修饰符
	- 参数个数和类型
	- 返回值类型
- 类（静态）常量
- 指向classloader的引用
- 指向class的引用

###### 方法表：

为了加快访问速度，虚拟机会为加载的每一个非抽象类，生成一个方法表，其中的元素是他的实例中所有实例方法的直接引用，包括从超类继承的方法

###### 堆：
java对象中包含的基本数据由它所属的类和超类中所有的实例变量组成。只要有一个对象引用，虚拟机就必须快速定位实例对象中的数据，并且能够通过对象访问相应的类数据（方法区中的类型信息），所以对象需要一个指向方法区的指针

两种堆空间设计方式

![](https://i.imgur.com/YiPXVZ2.png)
![](https://i.imgur.com/b4eH07I.png)
1. 堆内有句柄池和对象池，对象引用指向句柄，句柄池每个条目包含一个指向对象实例变量的指针和一个指向方法区类数据的指针
优点：移动对象的时候只需要改变句柄指针
缺点：每次访问对象的实例变量都需要传递两个指针
2. 对象引用指向一组数据，包含指向类数据的指针和对象实例数据
优点：访问只需要一个指针
缺点：移动对象的时候需要在整个运行时数据区更新指向被移动对象的引用，即所有对象引用

必须通过对象访问类数据的理由：
转换对象类型时，将会检查被转换对象是否是被引用的对象或超类，执行instanceof时也会执行相同检查（猜想：多态的实现方式）

虚拟机中的每个对象可以联系一个逻辑数据——对象锁，用于协调多个线程同时访问一个对象时的同步。在任何时刻只能有一个线程能拥有这个对象锁，有对象锁才能访问这个对象的数据，拥有之后这个线程可以多次加锁，加几次就要释放几次
每个对象还与等待集合相关联，使多个线程为了一个目标协调工作
```
//等待方法
wait()
//通知方法
notify()
notifyAll()
//每个类都会从Object继承这三个方法
//当调用这个wait()，虚拟机就将这个线程阻塞，放入等待集合中，当有线程调用通知方法时，虚拟机从等待集合唤醒一个或多个被阻塞线程
```
对象锁和等待集合一般只有在使用同步的时候才会产生

###### 程序计数器：
每个线程在启动的时候会创建一个pc寄存器，大小为一个字长，可以持有一个指针或者returnAddress。当线程执行一个方法时pc寄存器内容总是下一条指令的”地址“，这里的”地址“可以是一个本地指针、也可以是方法字节码中的偏移量。如果下一条为本地方法，pc寄存器为“undefined”

###### 栈帧：
由局部变量区、操作数栈和帧数据区组成

###### 局部变量区：
存储局部变量和方法参数，组织为一个从0开始以字长为单位的数据，int，float，reference和returnAddress占一项，byte、short和char都会转换成int也占一项，long和double占两项，正常方法会自传一个this的reference做参数，类方法不会

###### 操作数栈：
提供虚拟机指令的操作数，组织方式与局部变量相同，但是只能压栈出栈，取数计算再将结果压栈

###### 帧数据区：
支持常量池解析、正常方法返回以及异常派发机制

###### 本地方法栈：
的由java方法调用本地方法，内存不由虚拟机控制，参数会被压入本地方法的栈，即会压入当前帧的操作数栈。本地方法又会回调java语言来回到虚拟机。本地方法为java指令的扩展
	
###### 执行引擎：java程序的每个线程都是一个独立执行引擎的实例

指令集：方法的字节码流是由虚拟机指令序列构成
当执行引擎遇到一个本地方法的调用，由虚拟机试着发起这个调用，正常返回后，执行引擎继续执行字节码流的下一条指令

执行技术：解释，即时编译，自适应优化，芯片级直接执行
自适应优化，虚拟机将执行时间最长的字节码文件优化为极端优化的静态连接的c++本地方法。但是对于设计良好的java程序，方法调用和动态派发的频度会很高，方法调用会使优化器低效，java无法通过方法内嵌（将调用的方法拷贝到本方法中），因为可能方法会很大，因为自适应编译是在运行时优化所以可以利用调用信息将调用的方法内嵌

线程模型：java规范中，线程的行为通过变量，内存和工作内存来定义，每个java虚拟机实例都有一个主存，每个线程有一个工作内存

管理底层线程行为的规则规定以下操作：
- 将主存中的变量的值拷贝到工作内存
- 将它的值写回到主存
则会进一步牵扯到：原子性，顺序性，可视性的线程相关问题

###### Jvm调优的相关参数
主要为堆的大小、栈的大小、新生代和老年代的比值、新生代中eden和s0、s1的比值。

- -Xms:初始堆大小，默认是物理内存的1/64。默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。例如：-Xms 20m。
- -Xmx:最大堆大小。默认是物理内存的1/4  默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
- -XX:NewSize=xxx：设置年轻代大小（初始值）。 
- -XX:MaxNewSize：设置年轻代最大值。
- -XX:NewRatio=n:设置年轻代和年老代的比值。
- -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。
- -XX:PermSize（1.8之后改为MetaspaceSize）  设置持久代(perm gen)初始值，默认是物理内存的1/64。
- -XX:MaxPermSize=n:（1.8之后改为MaxMetaspaceSize）设置最大持久代大小。
- -Xss：每个线程的堆栈大小。



##### 6.x java class文件
java class文件是八位字节的二进制流

##### 7.x 类型的生命周期

**只有在第一次主动使用才会初始化**
所以外部类初始化时不会引起静态内部类的初始化

主动使用的情况：
- 创建某个类的新实例（new指令；不明确的创建、反射、克隆或者反序列化）
- 当调用某个类型的静态方法时
- 访问某个类或接口的静态字段，或对其赋值
- 使用java API中的反射方法时
- 初始化某个类的子类（初始化子类要求必须初始化超类）
- 启动类（含有main()）

###### 装载——连接——初始化
连接：验证——准备——解析（可选择）

- 装载：
1. 通过该类型全限定名，产生一个二进制数据流
2. 将这个二进制数据流解释为方法区的内部数据结构
3. 生成一个该类型的class实例对象

- 连接：
验证：确认类型符合java语言的语义
准备：确定要分配的内存大小，分配内存，将变量和引用设为默认值
解析：将常量池中的符号引用改为直接引用，也可以在使用时解析

初始化：
1）如果这个类有一个超类，还没有初始化，则先初始化超类
2）如果类中有初始化方法，则执行这个方法
类会使用类初始化方法<clinit>为类变量和静态类变量初始化
final变量在编译时初始化，则类不会用<clinit>初始化它

*ps:Class类的对象由系统创建，且只有一个对象，其中有加载类、获取类的属性、方法、构造器等方法，与java.lang.reflect类库中的Field、Method、Constructor类配合使用，获取类型信息；即类加载器机制*

###### 对象的生命周期

对象的创建：
- 直观地使用new时，调用Class或java.lang.reflect.Constructor中的Instance()方法
- 使用类型的clone()方法,通过java.io.ObjectInputStream类的getObject()方法反序列化

以及其他几种隐含创建情况：
- 保存命令行参数的String对象
- 装载时产生的Class对象
- 当虚拟机装载了常量池中包含CONSTANT_String_Info入口的类会创建新的String对象来存放这些常量字符串
- 执行字符串连接时会产生一个新的对象

对象初始化的不同方式：
- clone()产生，从被克隆的实例中的值拷贝到新对象中
- 序列化，从数据流中读取的值来初始化那些非暂时性的实例变量
否则，使用实例的初始化方法
- 虚拟机会为编译的类生成至少一个实例初始化方法，即<init>方法，针对源码中Meizu一个构造方法，编译器都会生成一个对应的<init>方法，如果没有定义构造方法编译器会生成一个默认的无参构造方法调用超类的一个无参构造方法。

<init>方法中包含：
- 如果显式调用类中另一个构造方法（this()）开始：
	- 一个同类<init>()的调用
	- 实现对应构造方法的方法体的字节码
- 如果没有从this()开始：
	- 一个超类的<init>()的调用
	- 任意实例变量的初始化的字节码
	- 实现对应构造方法的方法体的字节码
	- 如果显式调用super()，则会调用超类的对应的构造方法
	- 如果没有从this()、super()开始，则只会调用超类的无参构造方法
	
*多态的虚拟机实现方法的理解：类型加载时使用多态的实例变量的符号引用应为其超类，所以解析后的直接引用为超类引用*

##### 9.x 垃圾回收
根对象集：
局部变量的对象引用、方法栈中的操作数栈（以及类变量的对象应用）、加载的类的常量池中指向堆的对象引用、传递到本地方法中未释放的方法引用；

- 计数收集器：当一个对象创建的时候分配一个计数器，被引用一次则加一，当引用超过生命周期或者改变为其他值时减一。问题：只适用于长时间不被打断的对象，无法解决父类子类互相循环调用的问题

- 跟踪收集器：从根对象集出发，对每个对象做标记，处理掉没有被标记的对象

- 压缩收集器：解决堆碎块问题，将所有对象拷贝到堆的一端，将其他地方视为空，其中对象引用方式为带句柄，引用改变效率高，但是每次对象访问都有性能损失

- 拷贝收集器：解决堆碎块问题，将内存分为一块较大的Eden空间和两块较小的Survivor空间；每次使用Eden和其中一块Survivor。回收时将Eden和Sur中的对象复制到另一块Survivor中

- 按代收集的收集器：将堆分为多个子堆，按照寿命将对象分为多个代，越年轻的代则收集越频繁

内存分配策略：
- 大对象直接进入Old gen， -XX:PretenureSizeThreshold参数来控制这个大小，避免Eden以及Survivor区之间发生大量内存复制
- 空间分配担保：
	- 当Minor GC之前会检查新生代所有对象有没有大于Old gen空闲最大连续内存空间
	- 如果大于，则检查-XX:HandlePromotionFailure是否允许担保失败
	- 如果允许，将检查Old gen剩余最大连续内存空间是否大于历次GC晋升到Old gen的对象所占空间的平均值
	- 如果大于，则进行有风险的Minor GC，否则，进行Full GC

###### 火车算法：
火车算法把内存空间划分为固定大小的内存块，火车算法在这些块中执行，每个块属于一个集合，这个集合被称作火车，内存块被称作车厢；

车厢收集：
-. 每次火车算法执行都从最小数字火车开始，要么收集最小数字块、要么收集最小数字火车，当没有外部引用指向最小数字火车中的对象时，整个火车都为垃圾，被释放。
1. 假设最小数字火车中被认为全是垃圾，则释放整个火车，返回
2. 如果不全是垃圾，就关注最小数字车厢
	1. 首先、把所有被其他车厢应用的对象移动到其他车厢去
	2. 如果车厢内的对象都没有引用，则可以垃圾收集，释放整个车厢，返回；在这个过程中算法执行对象的移动或者释放

**->** 其中具体的转移操作：
1. 如果对象存在成熟空间之外的引用则把他移动到其他火车，如果被成熟空间中的其他火车引用，则移动到那个火车中去
2. 对这个对象进行扫描，查找对原车厢的引用，将存在的被引用对象也转移到这列火车
3. 对转移过来的对象在进行扫描，循环，直到没有指向原车厢的引用。
4. 当没有来自成熟空间之外以及其他火车的引用，则这节车厢中的对象剩余的外部引用都来自这列火车的其他车厢，算法把这样的对象移动到最小数字火车最后一个车厢去。
5. 扫描这些对象，将发现的引用对象也移动到同一列火车的尾部，也扫描，不断循环
6. 直到没有任何形式的引用指向被收集车厢，则释放被收集车厢的空间，返回

记忆集合：
记忆集合是包含一个车厢或者一列火车的引用集合，算法来为成熟对象空间的车厢和火车维护记忆集合，当记忆集合为空，则代表被遗忘可收集

问题：因为需要移动大量对象，当移动一个被引用很多的流行对象时，需要做的工作就会爆炸
终结方法的存在使垃圾回收更复杂，因为可能复活某些对象

19.x 方法调用
实例方法调用需要一个实例，类方法不需要
实例方法动态加载，类方法静态加载
调用类方法时，基于对象引用的类；
调用实例方法时，基于对象实际的类；
多态：。。。







