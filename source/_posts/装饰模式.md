---
title: 装饰模式
date: 2018-09-04 08:36:56
tags: [设计模式]
categories: 设计模式
respository: git@github.com:Gfeather/feather.git
branch: master
---

*learning ,  perception design* 

## 装饰模式

#### 定义

动态的给一个子类增加职责

#### 实现

```
//总接口
public interface Stream(){
	void read();
	void write(char a);
}
//装饰子类的抽象超类
public abstract class AbstractStream{
	protected Stream stream;
	AbstractStream(Stream stream){this.stream = stream;}
}
//缓冲装饰子类
public class BufferStream() extends AbstractStream{
	private Stream stream;
	private char buffer[];

	BufferStream(Stream stream){super(stream);}

	public char read(){
		//用Buffer读取一个字符
		return buffer[index--];
	}
	public void write(char a){
		//向buffer写入
		buffer[index++] = a; 
	}
}
//数据包装装饰子类
public class DataStream() extends AbstractStream(){
	private Stream stream;

	DataStream(Stream stream){super(stream);}

	public Char readChar(){
		//读取一个特定类型的数据，这里省略处理过程
		return (char)stream.read();
	}
	public void writeChar(char a){
		//写入一个特定类型数据
		stream.write((byte)a); 
	}
}
//流家族的这些具有特定功能的装饰子类内部使用相同的流对象，所以关闭流只需要调用最外层的流的关闭方法
```

#### 应用

这里举了Jdk中的流家族的栗子，其中使用的装饰器模式使获取缓冲和数据解析功能非常方便
> 优点：使用装饰模式拓展非常方便，可以在超类基础上拓展出具有同样功能，但是实现不同的子类
> 缺点：层次过多容易复杂

#### End
装饰器模式中的对象全部是一个对象，通过对接口中定义的基本方法做一定包装来获得新的能力。

*参考《设计模式之禅》*